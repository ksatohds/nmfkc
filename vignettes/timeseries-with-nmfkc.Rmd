---
title: "Time Series Analysis with NMF-VAR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Time Series Analysis with NMF-VAR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

This vignette demonstrates how to apply the `nmfkc` package to time series data using the **NMF-VAR (Non-negative Matrix Factorization - Vector Autoregression)** framework. This approach models the coefficient matrix of NMF as a VAR process ($B \approx C A_{lag}$), allowing for both dimensionality reduction and temporal modeling.

We will cover two scenarios:

1.  **Univariate AR:** Forecasting airline passengers (`AirPassengers`).
2.  **Multivariate VAR:** Analyzing macroeconomic indicators (`Canada`).

First, let's load the necessary packages.

```{r load-packages}
library(nmfkc)
library(vars) # For Canada dataset
```

-----

## Example 1: Univariate Autoregression with AirPassengers

The `AirPassengers` dataset contains monthly international airline passenger numbers. We will model this univariate time series using an autoregressive (AR) model.

### 1\. Data Preparation

We first log-transform the data to stabilize variance. **Crucially, we create a time vector and assign it as column names.** This is essential for plotting and for the `nmfkc.ar` functions to handle time indices correctly.

```{r air-data-prep}
d_air <- AirPassengers

# Create a time vector for the x-axis
time_air <- time(ts(1:length(d_air), start = c(1949, 1), frequency = 12))
time_vec_air <- round(as.vector(t(time_air)), 2)

# Create the initial data matrix (1 x N) with column names
Y0_air <- log10(matrix(as.vector(d_air), nrow = 1))
colnames(Y0_air) <- time_vec_air
rownames(Y0_air) <- "Passengers"
```

### 2\. Model Selection (Lag Order)

Instead of guessing the lag order, we can use **Cross-Validation** to find the optimal degree. We test lags from 1 to 14.

```{r air-degree-cv}
# Evaluate lag orders from 1 to 14
cv_res <- nmfkc.ar.degree.cv(Y0_air, rank = 1, degree = 1:14)

# Check the optimal degree
cv_res$degree

# For this example, we will proceed with D=12 (capturing monthly seasonality)
D <- 12
```

### 3\. Model Fitting

We construct the observation matrix `Y` and covariate matrix `A` (lagged Y) using `nmfkc.ar()`, then fit the model.

```{r air-model-fit}
# Create matrices for the AR(12) model
a_air <- nmfkc.ar(Y0_air, degree = D, intercept = TRUE)
Y_air <- a_air$Y
A_air <- a_air$A

# Fit the NMF-AR model (Rank=1 for univariate)
res_air <- nmfkc(Y = Y_air, A = A_air, rank = 1, epsilon = 1e-9)

# Check goodness of fit
res_air$r.squared

# Check for stationarity (spectral radius < 1)
nmfkc.ar.stationarity(res_air)
```

### 4\. Forecasting

We can forecast future values using the fitted model. Let's predict passengers for the next **2 years (24 months)**.

```{r air-forecast}
# --- 1. Forecast Generation ---
h <- 24
pred_res <- nmfkc.ar.predict(x = res_air, Y = Y0_air, n.ahead = h)
pred_val <- 10^as.vector(pred_res$pred) # Length = 24

# --- 2. Time Inference (Forced Length and Sequence) ---
# Get time properties from the original time series object
d_air <- AirPassengers 
total_len <- length(d_air)
start_time <- start(d_air)
freq <- frequency(d_air)

# Calculate the sequence of future time points
# Start time is the time of the LAST observed point + 1 period
pred_start_time <- start_time[1] + (start_time[2] + total_len) / freq
pred_time <- seq(from = pred_start_time, by = 1/freq, length.out = h) # Guaranteed length h

# --- 3. Plotting Preparation (Connect last observed point to forecast) ---
# Get the last observed point's data
last_obs_time <- tail(as.numeric(colnames(Y0_air)), 1)
last_obs_val  <- tail(10^as.vector(Y0_air), 1)

# Concatenate observed end point with forecast start point (Length = h + 1)
plot_pred_time <- c(last_obs_time, pred_time)
plot_pred_val  <- c(last_obs_val, pred_val) 

# Set plot limits
xlim_range <- range(c(as.numeric(colnames(Y0_air)), pred_time))
ylim_range <- range(c(10^as.vector(Y0_air), pred_val))

# --- 4. Plotting ---

# Plot Observed data (Black)
plot(as.numeric(colnames(Y0_air)), 10^(as.vector(Y0_air)), type = "l", col = "black", 
     xlim = xlim_range, ylim = ylim_range, lwd = 1,
     xlab = "Year", ylab = "Air Passengers", main = "NMF-VAR Forecast (h=24)")

# Fitted values during training (Red)
lines(as.numeric(colnames(Y_air)), 10^as.vector(res_air$XB), col = "red", lwd = 2)

# Future forecast (Blue) - Use the concatenated vectors (length 25)
lines(plot_pred_time, plot_pred_val, col = "blue", lwd = 2, lty = 2)

# Add legend
legend("topleft", legend = c("Observed", "Fitted", "Forecast"),
       col = c("black", "red", "blue"), lty = c(1, 1, 2), lwd = 2)
```

-----

## Example 2: Vector Autoregression with Canada Dataset

The `Canada` dataset contains four quarterly macroeconomic variables. We'll use a multivariate NMF-VAR model to analyze the relationship between these variables.

### 1\. Data Preparation

We take the first difference to achieve stationarity and normalize the data to $[0, 1]$.

```{r canada-data-prep}
# Load, difference, and normalize
d0_canada <- Canada
dd_canada <- apply(d0_canada, 2, diff)
dn_canada <- nmfkc.normalize(dd_canada)
Y0_canada <- t(dn_canada) # Variables x Time

# Create matrices for VAR(1)
a_canada <- nmfkc.ar(Y0_canada, degree = 1, intercept = TRUE)
Y_canada <- a_canada$Y
A_canada <- a_canada$A
```

### 2\. Model Fitting

We fit a model with `rank = 2` to identify two latent economic conditions driving the four variables.

```{r canada-model-fit}
# Fit the NMF-VAR model
res_canada <- nmfkc(Y = Y_canada, A = A_canada, rank = 2, prefix = "Condition", epsilon = 1e-6)

# R-squared and Stationarity
res_canada$r.squared
nmfkc.ar.stationarity(res_canada)
```

### 3\. Latent Structure & Causal Graph

We can visualize how the two latent conditions change over time.

```{r canada-soft-cluster}
# Visualize soft clustering of time trends
barplot(res_canada$B.prob, col = c(2, 3), border = NA,
        main = "Soft Clustering of Economic Conditions",
        xlab = "Time", ylab = "Probability",
        names.arg = colnames(Y_canada), las=2, cex.names = 0.5)
legend("topright", legend = colnames(res_canada$X), fill = c(2, 3), bg = "white")
```

Finally, we can generate a **DOT script** to visualize the Granger causality (relationships) between variables inferred by the model.

```{r canada-dot}
# Generate DOT script for graph visualization
# You can copy this output and render it using Graphviz (e.g., [http://magjac.com/graphviz-visual-editor/](http://magjac.com/graphviz-visual-editor/))
dot_script <- nmfkc.ar.DOT(res_canada, intercept = TRUE, digits = 2)
cat(substr(dot_script, 1, 300), "...\n(truncated)") # Show first 300 chars
```

